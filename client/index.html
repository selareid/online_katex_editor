<!DOCTYPE html>
<!-- KaTeX requires the use of the HTML5 doctype. Without it, KaTeX may not render properly -->
<html>
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
        <script>// Credit to Liam (Stack Overflow)
            // https://stackoverflow.com/a/41034697/3480193
            class Cursor {
                static getCurrentCursorPosition(parentElement) {
                    var selection = window.getSelection(),
                        charCount = -1,
                        node;
                    
                    if (selection.focusNode) {
                        if (Cursor._isChildOf(selection.focusNode, parentElement)) {
                            node = selection.focusNode; 
                            charCount = selection.focusOffset;
                            
                            while (node) {
                                if (node === parentElement) {
                                    break;
                                }
            
                                if (node.previousSibling) {
                                    node = node.previousSibling;
                                    charCount += node.textContent.length;
                                } else {
                                    node = node.parentNode;
                                    if (node === null) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    
                    return charCount;
                }
                
                static setCurrentCursorPosition(chars, element) {
                    if (chars >= 0) {
                        var selection = window.getSelection();
                        
                        let range = Cursor._createRange(element, { count: chars });
            
                        if (range) {
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                    }
                }
                
                static _createRange(node, chars, range) {
                    if (!range) {
                        range = document.createRange()
                        range.selectNode(node);
                        range.setStart(node, 0);
                    }
            
                    if (chars.count === 0) {
                        range.setEnd(node, chars.count);
                    } else if (node && chars.count >0) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            if (node.textContent.length < chars.count) {
                                chars.count -= node.textContent.length;
                            } else {
                                range.setEnd(node, chars.count);
                                chars.count = 0;
                            }
                        } else {
                            for (var lp = 0; lp < node.childNodes.length; lp++) {
                                range = Cursor._createRange(node.childNodes[lp], chars, range);
            
                                if (chars.count === 0) {
                                break;
                                }
                            }
                        }
                    } 
            
                    return range;
                }
                
                static _isChildOf(node, parentElement) {
                    while (node !== null) {
                        if (node === parentElement) {
                            return true;
                        }
                        node = node.parentNode;
                    }
            
                    return false;
                }
            }
        </script>
        <link href="style.css" rel="stylesheet">
    </head>
    <body>
        <p id="statusBox">STATUS: Loading!</p>
        <button onclick="location.href='?note=macros';" type="button">macros</button>
        <button onclick="location.href='viewer';" type="button">export</button>
        <button onclick="location.href='?note='+(prompt('Enter note name') || '');" type="button">open</button>
        
        <div id="katex_wrapper">
            <pre id="inputBox" contenteditable="true">\text{\Huge LOADING}</pre>
            <span id="outputBox"></span>
        </div>

        <script>
            var statusBox = document.getElementById("statusBox");
            var inputBox = document.getElementById("inputBox");
            var outputBox = document.getElementById("outputBox");
            var note_name = undefined;
            var posted_status = true;
            var upload_iterations = 0;

            const api_url = "/katex_api/";

            // try get note from server
            try {
                note_name = /note=([^&#=]*)/.exec(window.location.search)[1];

                var xmlHttp = new XMLHttpRequest();
                xmlHttp.open( "GET", api_url + note_name, false ); // false for synchronous request
                xmlHttp.send( null );
                console.log(xmlHttp.responseText);

                if (xmlHttp.status == 200) {
                    sessionStorage.setItem('katexAutosave', xmlHttp.responseText);
                }
            } catch(err) {
                console.log("oopsie", err);
            }

            // try load note
            inputBox.innerText = sessionStorage.getItem('katexAutosave') || "\\text{\\Huge Finished Loading!}";
            inputBox.focus();

            statusBox.innerText = "STATUS: Loaded";

            render(false);

            inputBox.addEventListener('input', function() {
                render();
            }, false);

            function render(sync=true) {
                try {
                    var text = inputBox.innerText;

                    if (sync) { // try upload
                        sessionStorage.setItem('katexAutosave', text);
                        
                        if (note_name !== undefined) storeNote(text);
                        else statusBox.innerText = "Not Uploading";
                    }

                    var html = katex.renderToString(text, {displayMode: true, trust: true});
                    outputBox.innerHTML = html;
                    outputBox.style.backgroundColor = '';
                }
                catch (e) {
                    if (e instanceof katex.ParseError) {
                        // KaTeX can't parse the expression
                        html = ("Error in LaTeX '" + text + "': " + e.message)
                            .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                        console.log(html);
                        // outputBox.innerHTML = pre_render + "\n" + html;
                        outputBox.style.backgroundColor = '#800000';

                        return;
                    } else {
                        throw e;  // other error
                    }
                }

                // //Only runs if no error in parsing! // //

                inputBox.style.height = outputBox.clientHeight + 'px';
                
                cursorPos = Cursor.getCurrentCursorPosition(inputBox);
                newInputHTML = colorInnerHTML(inputBox.innerHTML);
                if (newInputHTML != inputBox.innerHTML) {
                    inputBox.innerHTML = newInputHTML;
                    Cursor.setCurrentCursorPosition(cursorPos, inputBox);
                }
                
            }

            function storeNote(text) {
                upload_iterations += 1;

                if (posted_status) {
                    let this_upload_iteration = upload_iterations;
                    posted_status = false;

                    var xmlHttp = new XMLHttpRequest();
                    xmlHttp.open("POST", api_url + note_name, true); // true for asynchronous request
                    
                    xmlHttp.onload = function () {
                        posted_status = true;
                        console.log(xmlHttp.responseText);
                        statusBox.innerText = "Upload Status: " + xmlHttp.statusText + "\n Sync Status: " + (xmlHttp.status === 200 && this_upload_iteration===upload_iterations);
                    }

                    xmlHttp.send(text);
                }
                else {
                    statusBox.innerText = "Upload Status: Out Of Sync";
                }
            }

            function colorInnerHTML(text) {
                // console.log("pre " + text)


                //remove span tags from text
                text = text.replace(/(<span)[^>]*(>)/g, "");
                text = text.replace(/(<\/span>)/g, "");
                // console.log("post " + text);


                newText = '';
                state = 'zoom';
                updateI = 0;
                

                for (i=0;i<=text.length;i++) {
                    curChar = text[i];

                    switch (state) {
                        case 'zoom':
                            if (curChar == `\\`/* && text[i-1] != '>'*/) {
                                // console.log('foudn \ at '+i);
                                state = 'found_start';
                                newText += text.substring(updateI, i);
                                updateI = i;
                            }
                            else {
                                newText += text.substring(updateI, i);
                                updateI = i;
                            }
                            // console.log(curChar);
                            break;
                        case 'found_start':
                            // console.log('woulda been: ' + curChar + ' ' + i + ' ' + updateI)

                            if (['&', ' ', '{','}','<','>','='].includes(curChar) || i==text.length-1) { //handle end of highlight
                                newText += '<span style="color:#70d14d">' + text.substring(updateI, i) + '</span>';

                                updateI = i;
                                state = 'zoom';
                            }
                            else if (updateI != i && curChar=='\\') {
                                newText += '<span style="color:#70d14d">' + text.substring(updateI, i+1) + '</span>';

                                updateI = i+1;
                                state = 'zoom';
                            }
                            break;
                    }
                }

                return newText;
            }
        </script>
    </body>
</html>